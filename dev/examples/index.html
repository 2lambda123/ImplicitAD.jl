<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · ImplicitAD.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://byuflowlab.github.io/ImplicitAD.jl/examples/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImplicitAD.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Quick Start</a></li><li><a class="tocitem" href="../reference/">API</a></li><li><a class="tocitem" href="../theory/">Theory</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/ImplicitAD.jl/blob/main/docs/src/examples.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Let&#39;s go through a complete example now. Assume we have two nonlinear implicit equations:</p><p class="math-container">\[r_1(x, y) = (y_1 + x_1) (y_2^3 - x_2) + x_3 = 0
r_2(x, y) = \sin(y_2 \exp(y_1) - 1) x_4 = 0\]</p><p>We will use the NLsolve package to solve these equations (refer to the first example in their documentation if not familiar with NLsolve).  We will also put explict operations before and after the solve just to show how this will work in the midst of a larger program.  </p><pre><code class="language- hljs">
using NLsolve

function residual!(r, x, y)
    r[1] = (y[1] + x[1])*(y[2]^3-x[2])+x[3]
    r[2] = sin(y[2]*exp(y[1])-1)*x[4]
end

function solve(x)
    rwrap(r, y) = residual!(r, x[1:4], y)  # closure using some of the input variables within x just as an example
    res = nlsolve(rwrap, [0.1; 1.2], autodiff=:forward)
    return res.zero
end

function program(x)
    z = 2.0*x
    w = z + x.^2
    y = solve(w)
    return y[1] .+ w*y[2]
end
nothing # hide</code></pre><p>Now if we tried to run <code>ForwardDiff.jacobian(program, x)</code> it will not work.  It&#39;s not compatible with the internals of NLSolve, but even if it were it would be an inefficient way to compute the derivatives.  We now need to modify this script to use our package.  Here is what the modified <code>program</code> function will look like.</p><pre><code class="language-julia hljs">using ImplicitAD

function modprogram(x)
    z = 2.0*x
    w = z + x.^2
    y = implicit_function(solve, residual!, w)
    return y[1] .+ w*y[2]
end</code></pre><p>It is now both ForwardDiff and ReverseDiff compatible.</p><pre><code class="language- hljs">using ForwardDiff
using ReverseDiff

x = [1.0; 2.0; 3.0; 4.0; 5.0]

J1 = ForwardDiff.jacobian(modprogram, x)
J2 = ReverseDiff.jacobian(modprogram, x)
println(J1)
println(&quot;max abs difference = &quot;, maximum(abs.(J1 - J2)))</code></pre><h2 id="Overloading-Subfunctions"><a class="docs-heading-anchor" href="#Overloading-Subfunctions">Overloading Subfunctions</a><a id="Overloading-Subfunctions-1"></a><a class="docs-heading-anchor-permalink" href="#Overloading-Subfunctions" title="Permalink"></a></h2><p>As outlined in the math derivation, the forward mode consists of three main operations and custom implementations can be passed in.</p><ol><li><p><code>jvp(residual, x, y, v)</code>:  Compute the Jacobian vector product <code>b = B*v</code> where <span>$B_{ij} = \partial r_i/\partial x_j$</span>.  The default implementation uses forward mode AD where the Jacobian is not explicitly constructed (hence a Jacobian vector product).  This requires just evaluating the residual explicitly with dual numbers.</p></li><li><p><code>drdy(residual, x, y)</code>: Provide/compute or lazily instantiate <span>$\partial r_i/\partial y_j$</span>.  The default is forward mode AD.</p></li><li><p><code>lsolve(A, b)</code>: Solve linear system <span>$A x = b$</span> where <span>$A$</span> is computed in <code>drdy</code> and <span>$b$</span> is computed in <code>jvp</code>.  The default is the backsplash operator.</p></li></ol><p>In the reverse mode the operations are:</p><ol><li><p><code>drdy(residual, x, y)</code>: same as above.</p></li><li><p><code>lsolve(A, b)</code>: same as above (although the passed in <code>A</code> is now the transpose of the matrix computed in <code>drdy</code> and <span>$b$</span> is a provided input).</p></li><li><p><code>vjp(residual, x, y, v)</code>:  Compute the vector Jacobian product <span>$c = B^T v = (v^T B)^T$</span> where <span>$B_{ij} = \partial r_i/\partial x_j$</span>.  The default implementation uses reverse mode AD where the Jacobian is not explicitly constructed.  Instead only a gradient call is needed.</p></li></ol><p>Note that in all of these subfunctions <code>residual</code> is of the explicit form: <code>r = residual(x, y)</code>.  Since two of the functions are repeated, there are 4 functions that can be overriden if desired. Perhaps the most common would be to override <code>drdy</code> for cases where the Jacobian has significant sparsity, or is large so memory preallocation is important, or to apply a specific matrix factorization.  The linear solver <code>lsolve</code> might be overriden to use a Krylov method (in connection with using JVPs rather than an explicit <code>drdy</code>).  The functions <code>jvp</code> and <code>vjp</code> would be less commonly overriden, as they are efficient, but are available as needed.  There is also a keyword <code>drdx</code> where one can pass in a function of the same signature of <code>drdy</code> (but to compute <span>$\partial{r}/\partial{x}$</span>).  This is less commonly useful as both <code>jvp</code> and <code>vjp</code> would then use explicit matrix multiplication, but may be beneficial in some cases.</p><p>As an example of custom subfunctions, let&#39;s continue the same problem from the previous section.  We note that we can provide the Jacobian <span>$\partial r/\partial y$</span> analytically and so we will skip the internal ForwardDiff implementation. We provide our own function for <code>drdy</code>, and we will preallocate so we can modify the Jacobian in place:</p><pre><code class="language-julia hljs">function drdy(residual, x, y, A)
    A[1, 1] = y[2]^3-x[2]
    A[1, 2] = 3*y[2]^2*(y[1]+x[1])
    u = exp(y[1])*cos(y[2]*exp(y[1])-1)*x[4]
    A[2, 1] = y[2]*u
    A[2, 2] = u
    return A
end</code></pre><p>We can now pass this function in with a keyword argument to replace the default implementation for this subfunction.</p><pre><code class="language- hljs">
function modprogram2(x)
    z = 2.0*x
    w = z + x.^2
    A = zeros(2, 2)
    my_drdy(residual, x, y) = drdy(residual, x, y, A)
    y = implicit_function(solve, residual!, w, drdy=my_drdy)
    return y[1] .+ w*y[2]
end

J3 = ForwardDiff.jacobian(modprogram2, x)
println(maximum(abs.(J1 - J3)))
</code></pre><h2 id="Linear-residuals"><a class="docs-heading-anchor" href="#Linear-residuals">Linear residuals</a><a id="Linear-residuals-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-residuals" title="Permalink"></a></h2><p>If the residuals are linear (i.e., Ay = b) we could still use the above nonlinear formulation but it will be inefficient or require more work from the user.  Instead, we can provide the partial derivatives analytically for the user.  In this case, the user need only provide the inputs A and b.  </p><p>Let&#39;s consider a simple example.</p><pre><code class="language-julia hljs">using SparseArrays: sparse

function program(x)
    Araw = [x[1]*x[2] x[3]+x[4];
        x[3]+x[4] 0.0]
    b = [2.0, 3.0]
    A = sparse(Araw)
    y = A \ b
    z = y.^2
    return z
end</code></pre><p>This function is actually not compatible with ForwardDiff because of the use of a sparse matrix (obviously unnecessary with such a small matrix, just for illustration).  We now modify this function using this package, with a one line change using <code>implicit_linear_function</code>, and can now compute the Jacobian.</p><p>Let&#39;s consider a simple example.</p><pre><code class="language- hljs">using ImplicitAD
using ForwardDiff
using ReverseDiff

function modprogram(x)
    Araw = [x[1]*x[2] x[3]+x[4];
        x[3]+x[4] 0.0]
    b = [2.0, 3.0]
    A = sparse(Araw)
    y = implicit_linear_function(A, b)
    z = y.^2
    return z
end

x = [1.0; 2.0; 3.0; 4.0]
    
J1 = ForwardDiff.jacobian(modprogram, x)
J2 = ReverseDiff.jacobian(modprogram, x)

println(J1)
println(maximum(abs.(J1 - J2)))</code></pre><p>For <code>implicit_linear_function</code> there are two keywords for custom subfunctions: </p><ol><li><code>lsolve(A, b)</code>: same purpose as before: solve <span>$A x = b$</span> where the default is the backslash operator.</li><li><code>fact(A)</code>: provide a matrix factorization of A, since two linear solves are performed (for the primal and dual values).  default is <code>factorize</code> defined in <code>LinearAlgebra</code>.</li></ol></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 3 October 2022 19:59">Monday 3 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
