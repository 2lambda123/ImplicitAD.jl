<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ImplicitAD.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://byuflowlab.github.io/ImplicitAD.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ImplicitAD.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="tutorial/">Tutorial</a></li><li><a class="tocitem" href="reference/">API</a></li><li><a class="tocitem" href="theory/">Theory</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/ImplicitAD.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ImplicitAD-Documentation"><a class="docs-heading-anchor" href="#ImplicitAD-Documentation">ImplicitAD Documentation</a><a id="ImplicitAD-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#ImplicitAD-Documentation" title="Permalink"></a></h1><p><strong>Summary</strong>: Make implicit functions compatible with algorithmic differentiation without differenting inside the solvers. Also allow for custom rules with explicit functions (e.g., calling external code, mixed mode AD).</p><p><strong>Author</strong>: Andrew Ning and Taylor McDonnell</p><p><strong>Features</strong>:</p><ul><li>Compatible with ForwardDiff and ReverseDiff</li><li>Compatible with any solver (no differentiation occurs inside the solver)</li><li>Simple drop in functionality</li><li>Customizable subfunctions to accommodate different use cases</li><li>Version for ordinary differentiation equations (i.e., discrete adjoint)</li><li>Analytic overrides for linear systems (more efficient)</li><li>Analytic overrides for eigenvalue problems (more efficient)</li><li>Can provide custom rules to be inserted into the AD chain. Provides finite differencing and complex step defaults for cases where AD is not available (e.g., calling another language).</li></ul><p><strong>Implicit Motivation</strong>:</p><p>Many engineering analyses use implicit functions.  We can represent any such implicit function generally as:</p><p class="math-container">\[r(y; x) = 0\]</p><p>where <span>$r$</span> are the residual functions we wish to drive to zero, <span>$x$</span> are inputs, and <span>$y$</span> are the state variables, which are also outputs once the system of equations is solved.  In other words, <span>$y$</span> is an implicit function of <span>$x$</span> (<span>$x -&gt; r(y; x) -&gt; y$</span>).</p><p>We then chose some appropriate solver to converge these residuals.  From a differentiation perspective, we would like to compute <span>$dy/dx$</span>.  One can often use algorithmic differentiation (AD) in the same way one would for any explicit function.  Once we unroll the iterations of the solver the set of instructions is explicit.  However, this is at best inefficient and at worse inaccurate or not possible (at least not without a lot more effort).  To obtain accurate derivatives by propgating AD through a solver, the solver must be solved to a tight tolerance.  Generally tighter than is required to converge the primal values.  Sometimes this is not feasible because operations inside the solvers may not be overloaded for AD, this is especially true when calling solvers in other languages.  But even if we can do it (tight convergence is possible and everything under the hood is overloaded) we usually still shouldn&#39;t, as it would be computationally inefficient.  Instead we can use implicit differentiation, to allow for AD to work seemlessly with implicit functions without having to differentiate through them.</p><p>This package provides an implementation so that a simple one-line change can be applied to allow AD to be propgated around any solver.  Note that the implementation of the solver need not be AD compatible since AD does not not occur inside the solver.  This package is overloaded for <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> and <a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff.jl</a>.  There are also optional inputs so that subfunction behavior can be customized (e.g., preallocation, custom linear solvers, custom factorizations).</p><p><strong>Custom Rule Motivation</strong>:</p><p>A different but related need is to propagate AD through functions that are not-AD compatible. A common example would be a call to a subfunction in another language that is part of a larger AD compatible function. This packages provides a simple wrapper to estimate the derivatives of the subfunction with finite differencing (forward or central) or complex step.  Those derivatives are then inserted into the AD chain so that the overall function seamlessly works with ForwardDiff or ReverseDiff.</p><p>That same functionality is useful also in cases where a function is already AD compatible but where a more efficient rule is available.  We can provide the Jacobian or the Jacobian vector / vector Jacobian products directly.  One common example is mixed mode AD.  In this case we may have a subfunction that is most efficiently differentiated in reverse mode, but the overall function is differentiated in forward mode.  We can provide a custom rule for the subfunction which will then be inserted into the forward mode chain. </p><p><strong>Documentation</strong>:</p><ul><li>Start with the <a href="tutorial/">tutorial</a> to learn usage.</li><li>The API is described in the <a href="reference/">reference</a> page.</li><li>The math is particularly helpful for those wanting to provide their own custom subfunctions. See the <a href="theory/">theory</a> page.</li></ul><p><strong>Run Unit Tests</strong>:</p><pre><code class="language-julia hljs">pkg&gt; activate .
pkg&gt; test</code></pre><p><strong>Other Packages</strong>:</p><p><a href="https://julianonconvex.github.io/Nonconvex.jl/stable/gradients/implicit/">Nonconvex.jl</a> and <a href="https://github.com/gdalle/ImplicitDifferentiation.jl">ImplicitDifferentiation.jl</a> (a simplified version of the first package) are other prior implementations of the nonlinear case.  These two support ChainRules compatible packages and iterative linear solvers, whereas we have focused on ForwardDiff and ReverseDiff (though it will also work with ChainRules packages in reverse mode) and we support both direct and iterative solvers.  We&#39;ve also added specialized rules for linear solvers, and ordinary differential equations in the form of a discrete adjoint (or discrete direct/forward mode).  <a href="https://docs.sciml.ai/SciMLSensitivity/stable/manual/differential_equation_sensitivities/#sensitivity_diffeq">SciML</a> provides support for continuous adjoints of ODEs.  They have also recently added an implementation for the <a href="https://docs.sciml.ai/SciMLSensitivity/stable/manual/nonlinear_solve_sensitivities/">nonlinear case</a>, which looks to support a wide range of AD packages and also allows custom linear solvers.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="tutorial/">Tutorial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 2 March 2023 17:40">Thursday 2 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
