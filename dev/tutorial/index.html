<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · ImplicitAD.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://byuflowlab.github.io/ImplicitAD.jl/tutorial/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImplicitAD.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Overloading-Subfunctions"><span>Overloading Subfunctions</span></a></li><li><a class="tocitem" href="#Linear-residuals"><span>Linear residuals</span></a></li><li><a class="tocitem" href="#Custom-Rules"><span>Custom Rules</span></a></li></ul></li><li><a class="tocitem" href="../reference/">API</a></li><li><a class="tocitem" href="../theory/">Theory</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/ImplicitAD.jl/blob/main/docs/src/tutorial.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h1><p>We can generically represent the solver that converges the residuals and computes the corresponding state variables as:</p><p><code>y = solve(x, p)</code></p><p>Where x are variables and p are fixed parameters.  Our larger code may then have a mix of explicit and implicit functions.</p><pre><code class="language-julia hljs">function example(a)
    b = 2*a
    x = @. exp(b) + a
    y = solve(x)
    z = sqrt.(y)
    return z
end</code></pre><p>To make this function compatible we only need to replace the call to <code>solve</code> with an overloaded function <code>implicit</code> defined in this module:</p><pre><code class="language-julia hljs">using ImplicitAD

function example(a)
    b = 2*a
    x = @. exp(b) + a
    y = implicit(solve, residual, x)
    z = sqrt.(y)
    return z
end</code></pre><p>Note that the only new piece of information we need to expose is the residual function so that partial derivatives can be computed.  The new function is now compatible with ForwardDiff or ReverseDiff, for any solver, and efficiently provides the correct derivatives without differentiating inside the solver.</p><p>The residuals can either be returned:  <code>r = residual(y, x, p)</code>  or modified in place:  <code>residual!(r, y, x, p)</code>.</p><p>The input x should be a vector, and p is a tuple of fixed parameters.  The state and corresponding residuals, y and r, can be vectors or scalars (for 1D residuals).  The subfunctions are overloaded to handle both cases efficiently.</p><p>Limitation: ReverseDiff does not currently support compiling the tape for custome rules.  See this issue in ReverseDiff: https://github.com/JuliaDiff/ReverseDiff.jl/issues/187</p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Let&#39;s go through a complete example now. Assume we have two nonlinear implicit equations:</p><p class="math-container">\[r_1(x, y) = (y_1 + x_1) (y_2^3 - x_2) + x_3 = 0
r_2(x, y) = \sin(y_2 \exp(y_1) - 1) x_4 = 0\]</p><p>We will use the NLsolve package to solve these equations (refer to the first example in their documentation if not familiar with NLsolve).  We will also put explict operations before and after the solve just to show how this will work in the midst of a larger program.  In this case we use the in-place form of the residual function.</p><pre><code class="language-julia hljs">using NLsolve

function residual!(r, y, x, p)
    r[1] = (y[1] + x[1])*(y[2]^3-x[2])+x[3]
    r[2] = sin(y[2]*exp(y[1])-1)*x[4]
end

function solve(x, p)
    rwrap(r, y) = residual!(r, y, x[1:4], p)  # closure using some of the input variables within x just as an example
    res = nlsolve(rwrap, [0.1; 1.2], autodiff=:forward)
    return res.zero
end

function program(x)
    z = 2.0*x
    w = z + x.^2
    y = solve(w)
    return y[1] .+ w*y[2]
end</code></pre><p>Now if we tried to run <code>ForwardDiff.jacobian(program, x)</code> it will not work.  It&#39;s not compatible with the internals of NLSolve, but even if it were it would be an inefficient way to compute the derivatives.  We now need to modify this script to use our package.  Here is what the modified <code>program</code> function will look like.</p><pre><code class="language-julia hljs">using ImplicitAD

function modprogram(x)
    z = 2.0*x
    w = z + x.^2
    y = implicit(solve, residual!, w)
    return y[1] .+ w*y[2]
end</code></pre><p>It is now both ForwardDiff and ReverseDiff compatible.</p><pre><code class="language-julia hljs">using ForwardDiff
using ReverseDiff

x = [1.0; 2.0; 3.0; 4.0; 5.0]

J1 = ForwardDiff.jacobian(modprogram, x)
J2 = ReverseDiff.jacobian(modprogram, x)
println(J1)
println(&quot;max abs difference = &quot;, maximum(abs.(J1 - J2)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[8.05246842094794 1.94270623081742 -0.9587895057912197 -1.5408316665440452e-16 0.0; 8.555718860266143 14.330684545988305 -3.0818950100571225 -2.9040933686224584e-16 0.0; 16.807320957115106 12.267150376875744 4.727259400832726 -4.812659751532237e-16 0.0; 27.416523653063773 20.010483486419485 -9.875832623708009 13.476877646077641 0.0; 40.383326948112135 29.47455728697295 -14.546664733092996 -1.026570655984589e-15 16.172253175293168]
max abs difference = 7.105427357601002e-15</code></pre><h2 id="Overloading-Subfunctions"><a class="docs-heading-anchor" href="#Overloading-Subfunctions">Overloading Subfunctions</a><a id="Overloading-Subfunctions-1"></a><a class="docs-heading-anchor-permalink" href="#Overloading-Subfunctions" title="Permalink"></a></h2><p>If the user can provide (or lazily compute) their own partial derivatives for <span>$\partial{r}/\partial{y}$</span> then they can provide their own subfunction: <code>∂r∂y = drdy(residual, y, x, p)</code> (where <code>r = residual(y, x, p)</code>).  The default implementation computes these partials with ForwardDiff. Some examples where one may wish to override this behavior are for cases significant sparsity (e.g., using SparseDiffTools), for a large number of residuals (e.g., preallocating this Jacobian), or to provide a specific matrix factorization.</p><p>Additionally the user can override the linear solve: <code>x = lsolve(A, b)</code>.  The default is the backslash operator.  One example where a user may wish to override is to use matrix-free Krylov methods for large systems (in connection with the computation for ∂r∂y).</p><p>The other partials, ∂r/∂x, are not computed directly, but rather are used in efficient Jacobian vector (or vector Jacobian) products.</p><p>As an example, let&#39;s continue the same problem from the previous section.  We note that we can provide the Jacobian <span>$\partial r/\partial y$</span> analytically and so we will skip the internal ForwardDiff implementation. We provide our own function for <code>drdy</code>, and we will preallocate so we can modify the Jacobian in place:</p><pre><code class="language-julia hljs">function drdy(residual, y, x, p, A)
    A[1, 1] = y[2]^3-x[2]
    A[1, 2] = 3*y[2]^2*(y[1]+x[1])
    u = exp(y[1])*cos(y[2]*exp(y[1])-1)*x[4]
    A[2, 1] = y[2]*u
    A[2, 2] = u
    return A
end</code></pre><p>We can now pass this function in with a keyword argument to replace the default implementation for this subfunction.</p><pre><code class="language-julia hljs">function modprogram2(x)
    z = 2.0*x
    w = z + x.^2
    A = zeros(2, 2)
    my_drdy(residual, y, x, p) = drdy(residual, y, x, p, A)
    p = () # no parameters in this case
    y = implicit(solve, residual!, w, p, drdy=my_drdy)
    return y[1] .+ w*y[2]
end

J3 = ForwardDiff.jacobian(modprogram2, x)
println(maximum(abs.(J1 - J3)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0</code></pre><h2 id="Linear-residuals"><a class="docs-heading-anchor" href="#Linear-residuals">Linear residuals</a><a id="Linear-residuals-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-residuals" title="Permalink"></a></h2><p>If the residuals are linear (i.e., Ay = b) we could still use the above nonlinear formulation but it will be inefficient or require more work from the user.  Instead, we can provide the partial derivatives analytically for the user.  In this case, the user need only provide the inputs A and b.  </p><p>Let&#39;s consider a simple example.</p><pre><code class="language-julia hljs">using SparseArrays: sparse

function program(x)
    Araw = [x[1]*x[2] x[3]+x[4];
        x[3]+x[4] 0.0]
    b = [2.0, 3.0]
    A = sparse(Araw)
    y = A \ b
    z = y.^2
    return z
end</code></pre><p>This function is actually not compatible with ForwardDiff because of the use of a sparse matrix (obviously unnecessary with such a small matrix, just for illustration).  We now modify this function using this package, with a one line change using <code>implicit_linear</code>, and can now compute the Jacobian.</p><p>Let&#39;s consider a simple example.</p><pre><code class="language-julia hljs">using ImplicitAD
using ForwardDiff
using ReverseDiff

function modprogram(x)
    Araw = [x[1]*x[2] x[3]+x[4];
        x[3]+x[4] 0.0]
    b = [2.0, 3.0]
    A = sparse(Araw)
    y = implicit_linear(A, b)
    z = y.^2
    return z
end

x = [1.0; 2.0; 3.0; 4.0]

J1 = ForwardDiff.jacobian(modprogram, x)
J2 = ReverseDiff.jacobian(modprogram, x)

println(J1)
println(maximum(abs.(J1 - J2)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[-4.758098676964957e-17 -2.3790493384824785e-17 -0.052478134110787174 -0.052478134110787174; -0.03998334027488546 -0.01999167013744273 -0.0019039685845183543 -0.0019039685845183543]
6.938893903907228e-18</code></pre><p>For <code>implicit_linear</code> there are two keywords for custom subfunctions: </p><ol><li><code>lsolve(A, b)</code>: same purpose as before: solve <span>$A x = b$</span> where the default is the backslash operator.</li><li><code>fact(A)</code>: provide a matrix factorization of <span>$A$</span>, since two linear solves are performed (for the primal and dual values).  default is <code>factorize</code> defined in <code>LinearAlgebra</code>.</li></ol><h2 id="Custom-Rules"><a class="docs-heading-anchor" href="#Custom-Rules">Custom Rules</a><a id="Custom-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Rules" title="Permalink"></a></h2><p>Consider now explicit (or potentially implicit) functions of the form: <code>y = func(x, p)</code> where <code>x</code> are variables and <code>p</code> are fixed parameters.  For cases where <code>func</code> is not compatible with AD, or for cases where we have a more efficient rule, we will want to insert our own derivatives into the AD chain.  This functionality could also be used for mixed-mode AD.  For example, by wrapping some large section of code in a function that we reply reverse mode AD on, then using that as a custom rule for the overall code that might be operating in forward mode.  More complex nestings are of course possible.  </p><p>One common use case for a custom rule is when an external function call is needed, i.e., a function from another programming language is used within a larger Julia code.</p><p>We provide five options for injecting the derivatives of <code>func</code>.  You can provide the Jacobian <code>J = dy/dx</code>, or the JVPs/VJPs <span>$J v$</span> and <span>$v^T J$</span>.  Alternatively, you can allow the package to estimate the derivatives using forward finite differencing, central finite differencing, or complex step.  In forward operation (with the finite differencing options) the package will choose between computing the Jacobian first or computing JVPs directly in order to minimize the number of calls to <code>func</code>.  </p><p>Below is a simple example.  Let&#39;s first create a function, we call external, meant to represent a function that we cannot pass AD through (but of course can in this simple example).</p><pre><code class="language-julia hljs">function external(x, p)
    y = x.^2
    z = [x; y]
    return z
end</code></pre><p>Let&#39;s now call this function from our larger program that we wish to pass AD through:</p><pre><code class="language-julia hljs">function program(x)
    y = sin.(x)
    p = ()
    z = external(y, p)
    w = 5 * z
    return w
end</code></pre><p>Again, we assume that external is not AD compatible, so we modify this function with the <code>provide_rule</code> function provided in this package.</p><pre><code class="language-julia hljs">using ImplicitAD

function modprogram(x)
    y = sin.(x)
    p = ()
    z = provide_rule(external, y, p, &quot;ffd&quot;)
    w = 5 * z
    return w
end</code></pre><p>The last argument we provided is the mode, which can be either:</p><ul><li>&quot;ffd&quot;: forward finite differencing</li><li>&quot;cfd&quot;: central finite differencing</li><li>&quot;cs&quot;: complex step</li><li>&quot;jacobian&quot;: you provide <code>J = jacobian(x, p)</code>, use also keyword jacobian</li><li>&quot;vp&quot;: you provide Jacobian vector product <code>jvp(x, p, v)</code> and vector Jacobian product <code>vjp(x, p, v)</code> see keywords <code>jvp</code> and <code>vjp</code></li></ul><p>We can now use ForwardDiff or ReverseDiff and just the external code will be finite differenced (since we chose &quot;ffd&quot; above), and inserted into the AD chain.  Since this example is actually AD compatible everywhere we compare to using ForwardDiff through everything.</p><pre><code class="language- hljs">x = [1.0; 2.0; 3.0]
Jtrue = ForwardDiff.jacobian(program, x) 
J1 = ForwardDiff.jacobian(modprogram, x)
J2 = ReverseDiff.jacobian(modprogram, x)

println(Jtrue)
println(maximum(abs.(Jtrue - J1)))
println(maximum(abs.(Jtrue - J2)))</code></pre><p>Central difference and complex step work similarly.  The example, below shows how to provide the Jacobian.</p><pre><code class="language- hljs">using LinearAlgebra: diagm, I

function jacobian(x, p)
    dydx = diagm(2*x)
    dzdx = [I; dydx]
    return dzdx
end

function modprogram(x)
    y = sin.(x)
    p = ()
    z = provide_rule(external, y, p, &quot;jacobian&quot;; jacobian)
    w = 5 * z
    return w
end

J1 = ForwardDiff.jacobian(modprogram, x)
J2 = ReverseDiff.jacobian(modprogram, x)
println(maximum(abs.(Jtrue - J1)))
println(maximum(abs.(Jtrue - J2)))</code></pre><p>Finally, we show how to provide JVPs and VJPs.</p><pre><code class="language- hljs">
function jvp(x, p, v)
    nx = length(x)
    return [v; 2*x.*v]
end

function vjp(x, p, v)
    nx = length(x)
    return v[1:nx] .+ 2*x.*v[nx+1:end]
end

function modprogram(x)
    y = sin.(x)
    p = ()
    z = provide_rule(external, y, p, &quot;vp&quot;; jvp, vjp)
    w = 5 * z
    return w
end

J1 = ForwardDiff.jacobian(modprogram, x)
J2 = ReverseDiff.jacobian(modprogram, x)
println(maximum(abs.(Jtrue - J1)))
println(maximum(abs.(Jtrue - J2)))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../reference/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 13 October 2022 18:11">Thursday 13 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
